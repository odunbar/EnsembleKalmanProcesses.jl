var documenterSearchIndex = {"docs":
[{"location":"observations/#Observations","page":"Observations","title":"Observations","text":"","category":"section"},{"location":"observations/","page":"Observations","title":"Observations","text":"The Observations object is used to store the truth for convenience of the user. The ingredients are","category":"page"},{"location":"observations/","page":"Observations","title":"Observations","text":"Samples of the data Vector{Vector{Float}} or Array{Float,2}. If provided as a 2D array, the samples must be provided as columns. They are stored internally as Vector{Vector{Float}}\nAn optional covariance matrix can be provided.\nThe names of the data in this object as a String or Vector{String}","category":"page"},{"location":"observations/","page":"Observations","title":"Observations","text":"The empirical mean is calculated automatically. If a covariance matrix is not provided, then the empirical covariance is also calculated automatically.","category":"page"},{"location":"observations/#A-simple-example:","page":"Observations","title":"A simple example:","text":"","category":"section"},{"location":"observations/","page":"Observations","title":"Observations","text":"Here is a typical construction of the object","category":"page"},{"location":"observations/","page":"Observations","title":"Observations","text":"μ = zeros(5)\nΓy = rand(5,5)\nΓy = Γy'*Γy\nyt = rand(MvNormal(μ, Γy), 100) # generate 100 samples\nname = \"zero-mean mvnormal\"\n\ntrue_data = Observations.Obs(yt, Γy, name)","category":"page"},{"location":"observations/","page":"Observations","title":"Observations","text":"Currently, the data is retrieved by accessing the stored variables e.g the fifth data sample is given by truth_data.samples[5],or the covariance matrix by truth_data.cov.","category":"page"},{"location":"ensemble_kalman_sampler/#Ensemble-Kalman-Sampling","page":"Ensemble Kalman Sampler","title":"Ensemble Kalman Sampling","text":"","category":"section"},{"location":"ensemble_kalman_sampler/#What-Is-It-and-What-Does-It-Do?","page":"Ensemble Kalman Sampler","title":"What Is It and What Does It Do?","text":"","category":"section"},{"location":"ensemble_kalman_sampler/","page":"Ensemble Kalman Sampler","title":"Ensemble Kalman Sampler","text":"Ensemble Kalman Sampling (Garbuno-Inigo et al, 2019, Cleary et al, 2020) is a derivative-free optimization method that can be used to solve the inverse problem of finding the optimal model parameters given noisy data. In contrast to ensemble Kalman inversion (Iglesias et al, 2013), whose iterative updates result in a collapse of the ensemble onto the optimal parameter, the ensemble Kalman sampler generates approximate samples from the Bayesian posterior distribution of the parameter – i.e., it can be used not only for point estimation of the optimal parameter (as provided by the mean of the particles after the last iteration), but also for (approximative) uncertainty quantification (as provided by the covariance of the particles after the last iteration). ","category":"page"},{"location":"ensemble_kalman_sampler/","page":"Ensemble Kalman Sampler","title":"Ensemble Kalman Sampler","text":"The ensemble Kalman sampler is an interacting particle system in stochastic differential equation form, and it is based on a dynamic which transforms an arbitrary initial distribution into the desired posterior distribution, over an infinite time horizon – see Garbuno-Inigo et al, 2019, for a comprehensive description of the method. The ensemble Kalman sampling algorithm results from the introduction of a judiciously chosen noise to the ensemble Kalman inversion algorithm. Note that while there are also noisy variants of the standard ensemble Kalman inversion, ensemble Kalman sampling differs from them in its noise structure (its noise is added in parameter space, not in  data space), and its update rule explicitly accounts for the prior (rather than having it enter through initialization).","category":"page"},{"location":"ensemble_kalman_sampler/#Problem-Formulation","page":"Ensemble Kalman Sampler","title":"Problem Formulation","text":"","category":"section"},{"location":"ensemble_kalman_sampler/","page":"Ensemble Kalman Sampler","title":"Ensemble Kalman Sampler","text":"The data y and parameter vector theta are assumed to be related according to:","category":"page"},{"location":"ensemble_kalman_sampler/","page":"Ensemble Kalman Sampler","title":"Ensemble Kalman Sampler","text":"    y = mathcalG(theta) + eta","category":"page"},{"location":"ensemble_kalman_sampler/","page":"Ensemble Kalman Sampler","title":"Ensemble Kalman Sampler","text":"where mathcalG  mathbbR^p rightarrow mathbbR^d denotes the forward map, y in mathbbR^d is the vector of observations, and eta is the observational noise, which is assumed to be drawn from a d-dimensional Gaussian with distribution mathcalN(0 Gamma_y). The objective of the inverse problem is to compute the unknown parameters theta given the observations y, the known forward map mathcalG, and noise characteristics eta of the process. ","category":"page"},{"location":"ensemble_kalman_sampler/#Ensemble-Kalman-Sampling-Algorithm","page":"Ensemble Kalman Sampler","title":"Ensemble Kalman Sampling Algorithm","text":"","category":"section"},{"location":"ensemble_kalman_sampler/","page":"Ensemble Kalman Sampler","title":"Ensemble Kalman Sampler","text":"The ensemble Kalman sampler is based on the following update equation for the parameter vector theta^(j) of ensemble member j:","category":"page"},{"location":"ensemble_kalman_sampler/","page":"Ensemble Kalman Sampler","title":"Ensemble Kalman Sampler","text":"beginaligned\ntheta_n+1^(* j) = theta_n^(j) - dfracDelta t_nJsum_k=1^Jlangle mathcalG(theta_n^(k)) - barmathcalG_n Gamma_y^-1(mathcalG(theta_n^(j)) - y) rangle theta_n^(k) - Delta t_n mathsfC(Theta_n) Gamma_theta^-1 theta_n + 1^(* j) \ntheta_n + 1^j = theta_n+1^(* j) + sqrt2 Delta t_n mathsfC(Theta_n) xi_n^j\nendaligned","category":"page"},{"location":"ensemble_kalman_sampler/","page":"Ensemble Kalman Sampler","title":"Ensemble Kalman Sampler","text":"where the subscript n=1 dots N_it indicates the iteration, J is the ensemble size (i.e., the number of particles in the ensemble), Delta t_n is an adaptive time step, Gamma_theta is the prior covariance, and xi_n^(j) sim mathcalN(0 mathrmI). barmathcalG_n is the ensemble mean of mathcalG(theta),","category":"page"},{"location":"ensemble_kalman_sampler/","page":"Ensemble Kalman Sampler","title":"Ensemble Kalman Sampler","text":"barmathcalG_n = dfrac1Jsum_k=1^JmathcalG(theta_n^(k))","category":"page"},{"location":"ensemble_kalman_sampler/","page":"Ensemble Kalman Sampler","title":"Ensemble Kalman Sampler","text":"The p times p matrix mathsfC(Theta_n), where Theta_n = lefttheta^(j)right_j=1^J is the set of all ensemble particles in the nth iteration, denotes the empirical covariance between particles,","category":"page"},{"location":"ensemble_kalman_sampler/","page":"Ensemble Kalman Sampler","title":"Ensemble Kalman Sampler","text":"mathsfC(Theta_n) = frac1J sum_k=1^J (theta^(k) - bartheta) otimes (theta^(k) - bartheta)","category":"page"},{"location":"ensemble_kalman_sampler/","page":"Ensemble Kalman Sampler","title":"Ensemble Kalman Sampler","text":"where bartheta is the ensemble mean of the particles,","category":"page"},{"location":"ensemble_kalman_sampler/","page":"Ensemble Kalman Sampler","title":"Ensemble Kalman Sampler","text":"bartheta = dfrac1Jsum_k=1^Jtheta^(k)","category":"page"},{"location":"ensemble_kalman_sampler/#Constructing-the-Forward-Map","page":"Ensemble Kalman Sampler","title":"Constructing the Forward Map","text":"","category":"section"},{"location":"ensemble_kalman_sampler/","page":"Ensemble Kalman Sampler","title":"Ensemble Kalman Sampler","text":"At the core of the forward map mathcalG is the dynamical model PsimathbbR^p rightarrow mathbbR^o (running Psi is usually where the computational heavy-lifting is done), but the map mathcalG may include additional components such as a transformation of the (unbounded) parameters theta to a constrained domain the dynamical model can work with, or some post-processing of the output of Psi to generate the observations. For example, mathcalG may take the following form:","category":"page"},{"location":"ensemble_kalman_sampler/","page":"Ensemble Kalman Sampler","title":"Ensemble Kalman Sampler","text":"mathcalG = mathcalH circ Psi circ mathcalT^-1","category":"page"},{"location":"ensemble_kalman_sampler/","page":"Ensemble Kalman Sampler","title":"Ensemble Kalman Sampler","text":"where mathcalHmathbbR^o rightarrow mathbbR^d is the observation map and mathcalT is the transformation from the constrained to the unconstrained parameter space, such that mathcalT(phi)=theta. A family of standard transformations and their inverses are available in the ParameterDistributionStorage module.","category":"page"},{"location":"ensemble_kalman_sampler/#How-to-Construct-an-Ensemble-Kalman-Sampler","page":"Ensemble Kalman Sampler","title":"How to Construct an Ensemble Kalman Sampler","text":"","category":"section"},{"location":"ensemble_kalman_sampler/","page":"Ensemble Kalman Sampler","title":"Ensemble Kalman Sampler","text":"An ensemble Kalman sampling object can be created using the EnsembleKalmanProcess constructor by specifying the Sampler(prior_mean, prior_cov) process type.","category":"page"},{"location":"ensemble_kalman_sampler/","page":"Ensemble Kalman Sampler","title":"Ensemble Kalman Sampler","text":"Creating an ensemble Kalman inversion object requires as arguments:","category":"page"},{"location":"ensemble_kalman_sampler/","page":"Ensemble Kalman Sampler","title":"Ensemble Kalman Sampler","text":"An initial parameter ensemble – an array of size p × N_ens, where N_ens is the  ensemble size;","category":"page"},{"location":"ensemble_kalman_sampler/","page":"Ensemble Kalman Sampler","title":"Ensemble Kalman Sampler","text":"The mean value of the observed data – a vector of length d;","category":"page"},{"location":"ensemble_kalman_sampler/","page":"Ensemble Kalman Sampler","title":"Ensemble Kalman Sampler","text":"The covariance matrix of the observational noise – an array of size d × d;","category":"page"},{"location":"ensemble_kalman_sampler/","page":"Ensemble Kalman Sampler","title":"Ensemble Kalman Sampler","text":"The Sampler(prior_mean, prior_cov) process type, with the mean (a vector of length p) and the covariance (an array of size p x p) of the parameter's prior distribution","category":"page"},{"location":"ensemble_kalman_sampler/","page":"Ensemble Kalman Sampler","title":"Ensemble Kalman Sampler","text":"The following example shows how an ensemble Kalman sampling object is instantiated. The mean of the observational data (obs_mean) and the covariance of the observational noise (obs_cov) are assumed to be defined previously in the code.","category":"page"},{"location":"ensemble_kalman_sampler/","page":"Ensemble Kalman Sampler","title":"Ensemble Kalman Sampler","text":"using EnsembleKalmanProcesses.EnsembleKalmanProcessModule\nusing EnsembleKalmanProcesses.ParameterDistributionStorage  # required to create the prior\n\n# Construct prior (see `ParameterDistributionStorage.jl` docs)\nprior = ParameterDistribution(...)\nprior_mean = get_mean(prior)\nprior_cov = get_cov(prior)\n\n# Construct initial ensemble\nN_ens = 50  # ensemble size\ninitial_ensemble = construct_initial_ensemble(prior, N_ens) \n\n# Construct ensemble Kalman process \neks_process = Sampler(prior_mean, prior_cov)\neks_obj = EnsembleKalmanProcess(initial_ensemble, obs_mean, obs_noise_cov, eks_process)","category":"page"},{"location":"ensemble_kalman_sampler/#Updating-the-ensemble","page":"Ensemble Kalman Sampler","title":"Updating the ensemble","text":"","category":"section"},{"location":"ensemble_kalman_sampler/","page":"Ensemble Kalman Sampler","title":"Ensemble Kalman Sampler","text":"Once the ensemble Kalman sampling object eks_obj has been initialized, the initial ensemble of particles is iteratively updated by the update_ensemble! function, which takes as arguments the eks_obj and the evaluations of the forward model at each member of the current ensemble. In the following example, the forward map G maps a parameter to the corresponding data – this is done for each parameter in the ensemble, such that the resulting g_ens is of size d x N_ens. The update_ensemble! function then stores the updated ensemble as well as the evaluations of the forward map in eks_obj.","category":"page"},{"location":"ensemble_kalman_sampler/","page":"Ensemble Kalman Sampler","title":"Ensemble Kalman Sampler","text":"A typical use of the update_ensemble! function given the ensemble Kalman sampler object eks_obj, the dynamical model Ψ, and the observation map H (the latter two are assumed to be defined elsewhere, e.g. in a separate module)  may look as follows:","category":"page"},{"location":"ensemble_kalman_sampler/","page":"Ensemble Kalman Sampler","title":"Ensemble Kalman Sampler","text":"N_iter = 10 # Number of iterations\n\nfor n in 1:N_iter\n    θ_n = get_u_final(eks_obj) # Get current ensemble\n    ϕ_n = transform_unconstrained_to_constrained(prior, θ_n) # Transform parameters to physical/constrained space\n    G_n = [H(Ψ(ϕ_n[:, i])) for i in 1:J]  # Evaluate forward map\n    g_ens = hcat(G_n...)  # Reformat into `d x N_ens` matrix\n    update_ensemble!(eks_obj, g_ens) # Update ensemble\nend","category":"page"},{"location":"ensemble_kalman_sampler/#Solution","page":"Ensemble Kalman Sampler","title":"Solution","text":"","category":"section"},{"location":"ensemble_kalman_sampler/","page":"Ensemble Kalman Sampler","title":"Ensemble Kalman Sampler","text":"The solution of the ensemble Kalman sampling algorithm is a Gaussian distribution whose mean and covariance can be extracted from the ''last ensemble'' (i.e., the ensemble after the last iteration). The sample mean of the last ensemble is also the \"optimal\" parameter (θ_optim) for the given calibration problem. These statistics can be accessed as follows: ","category":"page"},{"location":"ensemble_kalman_sampler/","page":"Ensemble Kalman Sampler","title":"Ensemble Kalman Sampler","text":"using Statistics\n\n# mean of the Gaussian distribution, also the optimal parameter for the calibration problem\nθ_optim = mean(get_u_final(eks_obj), dims=2)\n# covariance of the Gaussian distribution\nsigma = cov(get_u_final(eks_obj), dims=2)","category":"page"},{"location":"API/Observations/#Observations","page":"Observations","title":"Observations","text":"","category":"section"},{"location":"API/Observations/","page":"Observations","title":"Observations","text":"CurrentModule = EnsembleKalmanProcesses.Observations","category":"page"},{"location":"API/Observations/","page":"Observations","title":"Observations","text":"Obs","category":"page"},{"location":"API/Observations/#EnsembleKalmanProcesses.Observations.Obs","page":"Observations","title":"EnsembleKalmanProcesses.Observations.Obs","text":"Obs{FT<:AbstractFloat}\n\nStructure that contains the observations\n\nFields\n\nsamples\nvector of observational samples, each of length sample_dim\nobs_noise_cov\ncovariance of the observational noise (assumed to be normally     distributed); sampledim x sampledim (where sampledim is the number of     elements in each sample), or a scalar if the sample dim is 1. If not     supplied, obsnoisecov is set to a diagonal matrix whose non-zero elements     are the variances of the samples, or to a scalar variance in the case of     1d samples. obsnoise_cov is set to nothing if only a single sample is     provided.\nmean\nsample mean\ndata_names\nnames of the data\n\n\n\n\n\n","category":"type"},{"location":"installation_instructions/#Installation","page":"Installation instructions","title":"Installation","text":"","category":"section"},{"location":"installation_instructions/","page":"Installation instructions","title":"Installation instructions","text":"To build the top-level project, first clone the repository, then instantiate:","category":"page"},{"location":"installation_instructions/","page":"Installation instructions","title":"Installation instructions","text":"cd CalibrateEmulateSample.jl\njulia --project -e 'using Pkg; Pkg.instantiate()","category":"page"},{"location":"installation_instructions/","page":"Installation instructions","title":"Installation instructions","text":"To test that the package is working:","category":"page"},{"location":"installation_instructions/","page":"Installation instructions","title":"Installation instructions","text":"> julia --project -e 'using Pkg; Pkg.test()'","category":"page"},{"location":"installation_instructions/#Building-the-documentation-locally","page":"Installation instructions","title":"Building the documentation locally","text":"","category":"section"},{"location":"installation_instructions/","page":"Installation instructions","title":"Installation instructions","text":"Once the project is built, you can build the project documentation under the docs/ sub-project:","category":"page"},{"location":"installation_instructions/","page":"Installation instructions","title":"Installation instructions","text":"julia --project=docs/ -e 'using Pkg; Pkg.instantiate()'\njulia --project=docs/ docs/make.jl","category":"page"},{"location":"installation_instructions/","page":"Installation instructions","title":"Installation instructions","text":"The locally rendered HTML documentation can be viewed at docs/build/index.html","category":"page"},{"location":"API/EnsembleKalmanProcessModule/#EnsembleKalmanProcessModule","page":"EnsembleKalmanProcessModule","title":"EnsembleKalmanProcessModule","text":"","category":"section"},{"location":"API/EnsembleKalmanProcessModule/","page":"EnsembleKalmanProcessModule","title":"EnsembleKalmanProcessModule","text":"CurrentModule = EnsembleKalmanProcesses.EnsembleKalmanProcessModule","category":"page"},{"location":"API/EnsembleKalmanProcessModule/","page":"EnsembleKalmanProcessModule","title":"EnsembleKalmanProcessModule","text":"Inversion\nSampler\nEnsembleKalmanProcess\nget_u\nget_g\nget_u_final\nget_N_iterations\nconstruct_initial_ensemble\nfind_ekp_stepsize\nupdate_ensemble!","category":"page"},{"location":"API/EnsembleKalmanProcessModule/#EnsembleKalmanProcesses.EnsembleKalmanProcessModule.Inversion","page":"EnsembleKalmanProcessModule","title":"EnsembleKalmanProcesses.EnsembleKalmanProcessModule.Inversion","text":"Inversion <: Process\n\nAn ensemble Kalman Inversion process\n\n\n\n\n\n","category":"type"},{"location":"API/EnsembleKalmanProcessModule/#EnsembleKalmanProcesses.EnsembleKalmanProcessModule.Sampler","page":"EnsembleKalmanProcessModule","title":"EnsembleKalmanProcesses.EnsembleKalmanProcessModule.Sampler","text":"Sampler{FT<:AbstractFloat,IT<:Int} <: Process\n\nAn ensemble Kalman Sampler process\n\n\n\n\n\n","category":"type"},{"location":"API/EnsembleKalmanProcessModule/#EnsembleKalmanProcesses.EnsembleKalmanProcessModule.EnsembleKalmanProcess","page":"EnsembleKalmanProcessModule","title":"EnsembleKalmanProcesses.EnsembleKalmanProcessModule.EnsembleKalmanProcess","text":"EnsembleKalmanProcess{FT<:AbstractFloat, IT<:Int}\n\nStructure that is used in Ensemble Kalman processes\n\n#Fields\n\nu\nArray of stores for parameters (u), each of size [Npar × Nens]\nobs_mean\nvector of the observed vector size [N_obs]\nobs_noise_cov\ncovariance matrix of the observational noise, of size [Nobs × Nobs]\nN_ens\nensemble size\ng\nArray of stores for forward model outputs, each of size  [Nobs × Nens]\nerr\nvector of errors\nΔt\nvector of timesteps used in each EK iteration\nprocess\nthe particular EK process (Inversion or Sampler)\n\n\n\n\n\n","category":"type"},{"location":"API/EnsembleKalmanProcessModule/#EnsembleKalmanProcesses.EnsembleKalmanProcessModule.get_u","page":"EnsembleKalmanProcessModule","title":"EnsembleKalmanProcesses.EnsembleKalmanProcessModule.get_u","text":"get_u(ekp::EnsembleKalmanProcess, iteration::IT; return_array=true) where {IT <: Integer}\n\nGet for the EKI iteration. Returns a DataContainer object unless array is specified.\n\n\n\n\n\nget_u(ekp::EnsembleKalmanProcess; return_array=true)\n\nGet for the EKI iteration. Returns a DataContainer object unless array is specified.\n\n\n\n\n\n","category":"function"},{"location":"API/EnsembleKalmanProcessModule/#EnsembleKalmanProcesses.EnsembleKalmanProcessModule.get_g","page":"EnsembleKalmanProcessModule","title":"EnsembleKalmanProcesses.EnsembleKalmanProcessModule.get_g","text":"get_g(ekp::EnsembleKalmanProcess, iteration::IT; return_array=true) where {IT <: Integer}\n\nGet for the EKI iteration. Returns a DataContainer object unless array is specified.\n\n\n\n\n\nget_g(ekp::EnsembleKalmanProcess; return_array=true)\n\nGet for the EKI iteration. Returns a DataContainer object unless array is specified.\n\n\n\n\n\n","category":"function"},{"location":"API/EnsembleKalmanProcessModule/#EnsembleKalmanProcesses.EnsembleKalmanProcessModule.get_u_final","page":"EnsembleKalmanProcessModule","title":"EnsembleKalmanProcesses.EnsembleKalmanProcessModule.get_u_final","text":"get_u_final(ekp::EnsembleKalmanProcess, return_array=true)\n\nGet the final or prior iteration of parameters or model ouputs, returns a DataContainer Object if return_array is false.\n\n\n\n\n\n","category":"function"},{"location":"API/EnsembleKalmanProcessModule/#EnsembleKalmanProcesses.EnsembleKalmanProcessModule.get_N_iterations","page":"EnsembleKalmanProcessModule","title":"EnsembleKalmanProcesses.EnsembleKalmanProcessModule.get_N_iterations","text":"get_N_iterations(ekp::EnsembleKalmanProcess\n\nget number of times update has been called (equals size(g), or size(u)-1) \n\n\n\n\n\n","category":"function"},{"location":"API/EnsembleKalmanProcessModule/#EnsembleKalmanProcesses.EnsembleKalmanProcessModule.construct_initial_ensemble","page":"EnsembleKalmanProcessModule","title":"EnsembleKalmanProcesses.EnsembleKalmanProcessModule.construct_initial_ensemble","text":"construct_initial_ensemble(prior::ParameterDistribution, N_ens::IT; rng_seed=42) where {IT<:Int}\n\nConstruct the initial parameters, by sampling N_ens samples from specified prior distribution. Returned with parameters as columns\n\n\n\n\n\n","category":"function"},{"location":"API/EnsembleKalmanProcessModule/#EnsembleKalmanProcesses.EnsembleKalmanProcessModule.find_ekp_stepsize","page":"EnsembleKalmanProcessModule","title":"EnsembleKalmanProcesses.EnsembleKalmanProcessModule.find_ekp_stepsize","text":"findekpstepsize(ekp::EnsembleKalmanProcess{FT, IT, Inversion}, g::Array{FT, 2}; cov_threshold::FT=0.01) where {FT}\n\nFind largest stepsize for the EK solver that leads to a reduction of the determinant of the sample covariance matrix no greater than cov_threshold. \n\n\n\n\n\n","category":"function"},{"location":"API/EnsembleKalmanProcessModule/#EnsembleKalmanProcesses.EnsembleKalmanProcessModule.update_ensemble!","page":"EnsembleKalmanProcessModule","title":"EnsembleKalmanProcesses.EnsembleKalmanProcessModule.update_ensemble!","text":"update_ensemble!(ekp::EnsembleKalmanProcess{FT, IT, <:Process}, g_in::Array{FT,2} cov_threshold::FT=0.01, Δt_new=nothing) where {FT, IT}\n\nUpdates the ensemble according to which type of Process we have. Model outputs gin need to be a outputdim × n_samples array (i.e data are columms)\n\n\n\n\n\n","category":"function"},{"location":"parameter_distributions/#Prior-distributions","page":"Prior distributions","title":"Prior distributions","text":"","category":"section"},{"location":"parameter_distributions/","page":"Prior distributions","title":"Prior distributions","text":"We provide a flexible setup for storing prior distribution with the ParameterDistributionStorage module found in src/ParameterDistribution.jl ","category":"page"},{"location":"parameter_distributions/","page":"Prior distributions","title":"Prior distributions","text":"One can create a full parameter distribution using three inputs.","category":"page"},{"location":"parameter_distributions/","page":"Prior distributions","title":"Prior distributions","text":"A Distribution, given as a ParameterDistributionType object\nAn array of Constraints, given as a Array{ConstraintType} object\nA Name, given as a String ","category":"page"},{"location":"parameter_distributions/","page":"Prior distributions","title":"Prior distributions","text":"One can also provide arrays of the triple (1.,2.,3.) to create more complex distributions","category":"page"},{"location":"parameter_distributions/#A-simple-example:","page":"Prior distributions","title":"A simple example:","text":"","category":"section"},{"location":"parameter_distributions/","page":"Prior distributions","title":"Prior distributions","text":"Task: We wish to create a prior for a one-dimensional parameter. Our problem dictates that this parameter is bounded between 0 and 1. Prior knowledge dictates it is around 0.7. The parameter is called \"point_seven\".","category":"page"},{"location":"parameter_distributions/","page":"Prior distributions","title":"Prior distributions","text":"Solution: We should use a Normal distribution with the predefined \"bounded\" constraint.","category":"page"},{"location":"parameter_distributions/","page":"Prior distributions","title":"Prior distributions","text":"Let's initialize the constraint first,","category":"page"},{"location":"parameter_distributions/","page":"Prior distributions","title":"Prior distributions","text":"constraint = [bounded(0,1)] # Sets up a logit-transformation into [0,1].","category":"page"},{"location":"parameter_distributions/","page":"Prior distributions","title":"Prior distributions","text":"The prior is around 0.7, and the push forward of a normal distribution N(mean=1,sd=0.5) gives a prior with 95% of it's mass between [0.5,0.88].","category":"page"},{"location":"parameter_distributions/","page":"Prior distributions","title":"Prior distributions","text":"distribution = Parameterized(Normal(1,0.5)) ","category":"page"},{"location":"parameter_distributions/","page":"Prior distributions","title":"Prior distributions","text":"Finally we attach the name","category":"page"},{"location":"parameter_distributions/","page":"Prior distributions","title":"Prior distributions","text":"name = \"point_seven\"","category":"page"},{"location":"parameter_distributions/","page":"Prior distributions","title":"Prior distributions","text":"And the distribution is created by calling:","category":"page"},{"location":"parameter_distributions/","page":"Prior distributions","title":"Prior distributions","text":"prior = ParameterDistribution(distribution,constraint,name)","category":"page"},{"location":"parameter_distributions/#.-The-ParameterDistributionType","page":"Prior distributions","title":"1. The ParameterDistributionType","text":"","category":"section"},{"location":"parameter_distributions/","page":"Prior distributions","title":"Prior distributions","text":"The ParameterDistributionType has 2 flavours for building a distribution.","category":"page"},{"location":"parameter_distributions/","page":"Prior distributions","title":"Prior distributions","text":"The Parameterized type is initialized using a Julia Distributions.jl object. Samples are drawn randomly from the distribution object\nThe Samples type is initialized using a two dimensional array. Samples are drawn randomly (with replacement) from the columns of the provided array","category":"page"},{"location":"parameter_distributions/","page":"Prior distributions","title":"Prior distributions","text":"One can use combinations of these distributions to construct a full parameter distribution.","category":"page"},{"location":"parameter_distributions/","page":"Prior distributions","title":"Prior distributions","text":"note: Note\nWe recommend these distributions be unbounded (see about constraints below), as our methods do not preserve constraints directly.","category":"page"},{"location":"parameter_distributions/#.-The-ConstraintType","page":"Prior distributions","title":"2. The ConstraintType","text":"","category":"section"},{"location":"parameter_distributions/","page":"Prior distributions","title":"Prior distributions","text":"Our implemented algorithms do not work in constrained parameter space directly. Therefore, constraints are tackled by the mappings transform_constrained_to_unconstrained and transform_unconstrained_to_constrained. The mappings are built from either predefined or user-defined constraint functions held in the ConstraintType. ","category":"page"},{"location":"parameter_distributions/","page":"Prior distributions","title":"Prior distributions","text":"In this section we call parameters are one-dimensional. Every parameter must have an associated independent ConstraintType, therefore we for each ParameterDistributionType of dimension p the user must provide a p-dimensional Array{ConstraintType}.","category":"page"},{"location":"parameter_distributions/#Predefined-ConstraintTypes","page":"Prior distributions","title":"Predefined ConstraintTypes","text":"","category":"section"},{"location":"parameter_distributions/","page":"Prior distributions","title":"Prior distributions","text":"We provide some ConstraintTypes, which apply different transformations internally to enforce bounds on physical parameter spaces. The types have the following constructors","category":"page"},{"location":"parameter_distributions/","page":"Prior distributions","title":"Prior distributions","text":"no_constraint(), no transform is required for this parameter\nbounded_below(lower_bound), the physical parameter has a (provided) lower bound\nbounded_above(upper_bound), the physical parameter has a (provided) upper bound \nbounded(lower_bound,upper_bound), the physical parameter has the (provided) bounds","category":"page"},{"location":"parameter_distributions/","page":"Prior distributions","title":"Prior distributions","text":"Users can also define their own transformations by directly creating a ConstraintType object with their own mappings.","category":"page"},{"location":"parameter_distributions/","page":"Prior distributions","title":"Prior distributions","text":"note: Note\nIt is up to the user to ensure their provided transforms are inverses of each other.","category":"page"},{"location":"parameter_distributions/#.-The-name","page":"Prior distributions","title":"3. The name","text":"","category":"section"},{"location":"parameter_distributions/","page":"Prior distributions","title":"Prior distributions","text":"This is simply an identifier for the parameters later on.","category":"page"},{"location":"parameter_distributions/#A-more-involved-example:","page":"Prior distributions","title":"A more involved example:","text":"","category":"section"},{"location":"parameter_distributions/","page":"Prior distributions","title":"Prior distributions","text":"We create a 6-dimensional parameter distribution from 2 triples.","category":"page"},{"location":"parameter_distributions/","page":"Prior distributions","title":"Prior distributions","text":"The first triple is a 4-dimensional distribution with the following constraints on parameters in physical space:","category":"page"},{"location":"parameter_distributions/","page":"Prior distributions","title":"Prior distributions","text":"c1 = [no_constraint(), # no constraints\n      bounded_below(-1.0), # provide lower bound\n      bounded_above(0.4), # provide upper bound\n      bounded(-0.1,0.2)] # provide lower and upper bound","category":"page"},{"location":"parameter_distributions/","page":"Prior distributions","title":"Prior distributions","text":"We choose to use a multivariate normal to represent its distribution in the transformed (unbounded) space. Here we take a tridiagonal covariance matrix.","category":"page"},{"location":"parameter_distributions/","page":"Prior distributions","title":"Prior distributions","text":"diag_val = 0.5*ones(4)\nudiag_val = 0.25*ones(3)\nmean = ones(4)\ncovariance = SymTridiagonal(diagonal_val, udiag_val)\nd1 = Parameterized(MvNormal(mean,covariance)) # 4D multivariate normal","category":"page"},{"location":"parameter_distributions/","page":"Prior distributions","title":"Prior distributions","text":"We also provide a name","category":"page"},{"location":"parameter_distributions/","page":"Prior distributions","title":"Prior distributions","text":"name1 = \"constrained_mvnormal\"","category":"page"},{"location":"parameter_distributions/","page":"Prior distributions","title":"Prior distributions","text":"The second triple is a 2-dimensional one. It is only given by 4 samples in the transformed space - (where one will typically generate samples). It is bounded in the first dimension by the constraint shown, there is a user provided transform for the second dimension - using the default constructor.","category":"page"},{"location":"parameter_distributions/","page":"Prior distributions","title":"Prior distributions","text":"d2 = Samples([1.0 3.0; 5.0 7.0; 9.0 11.0; 13.0 15.0]) # 4 samples of 2D parameter space\ntransform = (x -> 3*x + 14)\ninverse_transform = (x -> (x-14) / 3)\nc2 = [bounded(10,15),\n      Constraint(transform, inverse_transform)]\nname2 = \"constrained_sampled\"","category":"page"},{"location":"parameter_distributions/","page":"Prior distributions","title":"Prior distributions","text":"The full prior distribution for this setting is created with arrays of our two triples","category":"page"},{"location":"parameter_distributions/","page":"Prior distributions","title":"Prior distributions","text":"u = ParameterDistribution([d1,d2],[c1,c2],[name1,name2])","category":"page"},{"location":"parameter_distributions/#Other-functions","page":"Prior distributions","title":"Other functions","text":"","category":"section"},{"location":"parameter_distributions/","page":"Prior distributions","title":"Prior distributions","text":"These functions typically return a Dict with ParameterDistribution.name as a keys, or an Array if requested ","category":"page"},{"location":"parameter_distributions/","page":"Prior distributions","title":"Prior distributions","text":"get_name: returns the names\nget_distribution: returns the Julia Distribution object if it is Parameterized\nsample_distribution: samples the Julia Distribution if Parameterized, or draws from the list of samples if Samples\ntransform_unconstrained_to_constrained: Apply the constraint mappings\ntransform_constrained_to_unconstrained: Apply the inverse constraint mappings ","category":"page"},{"location":"glossary/#Glossary","page":"Glossary","title":"Glossary","text":"","category":"section"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"The following list includes the names and symbols of recurring concepts in EnsembleKalmanProcesses.jl. Some of these variables do not appear in the codebase, which relies on array programming for performance.  Contributions to the codebase require following this notational convention. Similarly, if you find inconsistencies in the documentation or codebase, please report an issue on GitHub.","category":"page"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"Name Symbol (Theory/Docs) Symbol (Code)\nParameter vector, Parameters (unconstrained space) theta theta\nParameter vector size, Number of parameters p N_par\nEnsemble size J N_ens\nEnsemble particles, members theta^(j) \nNumber of iterations N_it N_iter\nObservation vector, Observations, Data vector y y\nObservation vector size, Data vector size d N_obs\nObservational noise eta obs_noise\nObservational noise covariance Gamma_y obs_noise_cov\nHilbert space inner product langle phi Gamma^-1 psirangle \nForward map mathcalG G\nDynamical model Psi Psi\nTransform map (constrained to unconstrained) mathcalT T\nObservation map mathcalH H\nPrior covariance (unconstrained space) Gamma_theta prior_cov\nPrior mean (unconstrained space) m_theta prior_mean","category":"page"},{"location":"examples/template_example/#Template-example","page":"Template example","title":"Template example","text":"","category":"section"},{"location":"examples/template_example/","page":"Template example","title":"Template example","text":"We provide the following template for how the tools may be applied.","category":"page"},{"location":"examples/template_example/","page":"Template example","title":"Template example","text":"For small examples typically have 2 files.","category":"page"},{"location":"examples/template_example/","page":"Template example","title":"Template example","text":"GModel.jl Contains the forward map. The inputs should be the so-called free parameters we are interested in learning, and the output should be the measured data\nThe example script which contains the inverse problem setup and solve","category":"page"},{"location":"examples/template_example/#The-structure-of-the-example-script","page":"Template example","title":"The structure of the example script","text":"","category":"section"},{"location":"examples/template_example/","page":"Template example","title":"Template example","text":"First we create the data and the setting for the model","category":"page"},{"location":"examples/template_example/","page":"Template example","title":"Template example","text":"Set up the forward model.\nConstruct/load the truth data. Store this data conveniently in the Observations.Obs object","category":"page"},{"location":"examples/template_example/","page":"Template example","title":"Template example","text":"Then we set up the inverse problem","category":"page"},{"location":"examples/template_example/","page":"Template example","title":"Template example","text":"Define the prior distributions. Use the ParameterDistribution object\nDecide on which process tool you would like to use (we recommend you begin with Invesion()). Then initialize this with the relevant constructor\ninitialize the EnsembleKalmanProcess object","category":"page"},{"location":"examples/template_example/","page":"Template example","title":"Template example","text":"Then we solve the inverse problem, in a loop perform the following for as many iterations as required:","category":"page"},{"location":"examples/template_example/","page":"Template example","title":"Template example","text":"Obtain the current parameter ensemble\nTransform them from the unbounded computational space to the physical space\ncall the forward map on the ensemble of parameters, producing an ensemble of measured data\ncall the update_ensemble! function to generate a new parameter ensemble based on the new data","category":"page"},{"location":"examples/template_example/","page":"Template example","title":"Template example","text":"One can then obtain the solution, dependent on the process type.","category":"page"},{"location":"ensemble_kalman_inversion/#Ensemble-Kalman-Inversion","page":"Ensemble Kalman Inversion","title":"Ensemble Kalman Inversion","text":"","category":"section"},{"location":"ensemble_kalman_inversion/","page":"Ensemble Kalman Inversion","title":"Ensemble Kalman Inversion","text":"One of the ensemble Kalman processes implemented in EnsembleKalmanProcesses.jl is the ensemble Kalman inversion (Iglesias et al, 2013). The ensemble Kalman inversion (EKI) is a derivative-free ensemble optimization method that seeks to find the optimal parameters theta in mathbbR^p in the inverse problem","category":"page"},{"location":"ensemble_kalman_inversion/","page":"Ensemble Kalman Inversion","title":"Ensemble Kalman Inversion","text":"\\[ y = \\mathcal{G}(\\theta) + \\eta, \\]","category":"page"},{"location":"ensemble_kalman_inversion/","page":"Ensemble Kalman Inversion","title":"Ensemble Kalman Inversion","text":"where mathcalG denotes the forward map, y in mathbbR^d is the vector of observations and eta sim mathcalN(0 Gamma_y) is additive Gaussian observational noise. Note that p is the size of the parameter vector theta and d is taken to be the size of the observation vector y. The EKI update equation for parameter vector theta^(j) of ensemble member j is","category":"page"},{"location":"ensemble_kalman_inversion/","page":"Ensemble Kalman Inversion","title":"Ensemble Kalman Inversion","text":"theta_n+1^(j) = theta_n^(j) - dfracDelta t_nJsum_k=1^Jlangle mathcalG(theta_n^(k)) - barmathcalG_n Gamma_y^-1(mathcalG(theta_n^(j)) - y) rangle theta_n^(k)","category":"page"},{"location":"ensemble_kalman_inversion/","page":"Ensemble Kalman Inversion","title":"Ensemble Kalman Inversion","text":"where the subscript n=1 dots N_it indicates the iteration, J is the number of members in the ensemble and barmathcalG_n is the mean value of mathcalG(theta) across ensemble members,","category":"page"},{"location":"ensemble_kalman_inversion/","page":"Ensemble Kalman Inversion","title":"Ensemble Kalman Inversion","text":"barmathcalG_n = dfrac1Jsum_k=1^JmathcalG(theta_n^(k))","category":"page"},{"location":"ensemble_kalman_inversion/","page":"Ensemble Kalman Inversion","title":"Ensemble Kalman Inversion","text":"The EKI algorithm is considered converged when the ensemble achieves sufficient consensus/collapse in parameter space. The final estimate bartheta_N_it is taken to be the ensemble mean at the final iteration,","category":"page"},{"location":"ensemble_kalman_inversion/","page":"Ensemble Kalman Inversion","title":"Ensemble Kalman Inversion","text":"bartheta_N_it = dfrac1Jsum_k=1^Jtheta_N_it^(k)","category":"page"},{"location":"ensemble_kalman_inversion/","page":"Ensemble Kalman Inversion","title":"Ensemble Kalman Inversion","text":"For typical applications, a near-optimal solution theta can be found after as few as 10 iterations of the algorithm. The obtained solution is optimal in the sense of the mean squared error loss, details can be found in Iglesias et al (2013). The algorithm performs better with larger ensembles. As a rule of thumb, the number of members in the ensemble should be larger than 10p, although the optimal ensemble size may depend on the problem setting and the computational power available.","category":"page"},{"location":"ensemble_kalman_inversion/#Constructing-the-Forward-Map","page":"Ensemble Kalman Inversion","title":"Constructing the Forward Map","text":"","category":"section"},{"location":"ensemble_kalman_inversion/","page":"Ensemble Kalman Inversion","title":"Ensemble Kalman Inversion","text":"The forward map mathcalG maps the space of unconstrained parameters theta in mathbbR^p to the outputs yin mathbbR^d. In practice, the user may not have access to such a map directly. Consider a situation where the goal is to learn a set of parameters phi of a dynamical model PsimathbbR^p rightarrow mathbbR^o, given observations y in mathbbR^d and a set of constraints on the value of phi. Then, the forward map may be constructed as","category":"page"},{"location":"ensemble_kalman_inversion/","page":"Ensemble Kalman Inversion","title":"Ensemble Kalman Inversion","text":"mathcalG = mathcalH circ Psi circ mathcalT^-1","category":"page"},{"location":"ensemble_kalman_inversion/","page":"Ensemble Kalman Inversion","title":"Ensemble Kalman Inversion","text":"where mathcalHmathbbR^o rightarrow mathbbR^d is the observation map and mathcalT is the transformation map from constrained to unconstrained parameter spaces, such that mathcalT(phi)=theta. A family of standard transformation maps and their inverse are available in the ParameterDistributionStorage module.","category":"page"},{"location":"ensemble_kalman_inversion/#Creating-the-EKI-Object","page":"Ensemble Kalman Inversion","title":"Creating the EKI Object","text":"","category":"section"},{"location":"ensemble_kalman_inversion/","page":"Ensemble Kalman Inversion","title":"Ensemble Kalman Inversion","text":"An ensemble Kalman inversion object can be created using the EnsembleKalmanProcess constructor by specifying the Inversion() process type.","category":"page"},{"location":"ensemble_kalman_inversion/","page":"Ensemble Kalman Inversion","title":"Ensemble Kalman Inversion","text":"Creating an ensemble Kalman inversion object requires as arguments:","category":"page"},{"location":"ensemble_kalman_inversion/","page":"Ensemble Kalman Inversion","title":"Ensemble Kalman Inversion","text":"An initial parameter ensemble, Array{FT, 2} of size [p × J];\nThe mean value of the observed outputs, a vector of size [d];\nThe covariance of the observational noise, a matrix of size [d × d]\nThe Inversion() process type.","category":"page"},{"location":"ensemble_kalman_inversion/","page":"Ensemble Kalman Inversion","title":"Ensemble Kalman Inversion","text":"A typical initialization of the Inversion() process takes a user-defined prior, a summary of the observation statistics given by the mean y and covariance obs_noise_cov, and a desired number of members in the ensemble,","category":"page"},{"location":"ensemble_kalman_inversion/","page":"Ensemble Kalman Inversion","title":"Ensemble Kalman Inversion","text":"using EnsembleKalmanProcesses.EnsembleKalmanProcessModule\nusing EnsembleKalmanProcesses.ParameterDistributionStorage\n\nJ = 50  # number of ensemble members\ninitial_ensemble = construct_initial_ensemble(prior, J) # Initialize ensemble from prior\n\nekiobj = EnsembleKalmanProcess(initial_ensemble, y, obs_noise_cov, Inversion())","category":"page"},{"location":"ensemble_kalman_inversion/","page":"Ensemble Kalman Inversion","title":"Ensemble Kalman Inversion","text":"See the Prior distributions section to learn about the construction of priors in EnsembleKalmanProcesses.jl. The prior is assumed to be over the unconstrained parameter space where theta is defined. For applications where enforcing parameter bounds is necessary, the ParameterDistributionStorage module provides functions to map from constrained to unconstrained space and viceversa. ","category":"page"},{"location":"ensemble_kalman_inversion/#Updating-the-Ensemble","page":"Ensemble Kalman Inversion","title":"Updating the Ensemble","text":"","category":"section"},{"location":"ensemble_kalman_inversion/","page":"Ensemble Kalman Inversion","title":"Ensemble Kalman Inversion","text":"Once the ensemble Kalman inversion object ekiobj has been initialized, any number of updates can be performed using the inversion algorithm.","category":"page"},{"location":"ensemble_kalman_inversion/","page":"Ensemble Kalman Inversion","title":"Ensemble Kalman Inversion","text":"A call to the inversion algorithm can be performed with the update_ensemble! function. This function takes as arguments the ekiobj and the evaluations of the forward map at each member of the current ensemble. The update_ensemble! function then stores the new updated ensemble and the inputted forward map evaluations in ekiobj. ","category":"page"},{"location":"ensemble_kalman_inversion/","page":"Ensemble Kalman Inversion","title":"Ensemble Kalman Inversion","text":"A typical use of the update_ensemble! function given the ensemble Kalman inversion object ekiobj, the dynamical model Ψ and the observation map H is","category":"page"},{"location":"ensemble_kalman_inversion/","page":"Ensemble Kalman Inversion","title":"Ensemble Kalman Inversion","text":"N_iter = 20 # Number of steps of the algorithm\n\nfor n in 1:N_iter\n    θ_n = get_u_final(ekiobj) # Get current ensemble\n    ϕ_n = transform_unconstrained_to_constrained(prior, θ_n) # Transform parameters to physical/constrained space\n    G_n = [ H( Ψ((ϕ_n[:,i]) ) for i in 1:J]\n    g_ens = hcat(G_n...) # Evaluate forward map\n    update_ensemble!(ekiobj, g_ens) # Update ensemble\nend","category":"page"},{"location":"ensemble_kalman_inversion/","page":"Ensemble Kalman Inversion","title":"Ensemble Kalman Inversion","text":"In the previous update, note that the parameters stored in ekiobj are given in the unconstrained Gaussian space where the EKI algorithm is performed. The map mathcalT^-1 between this unconstrained space and the (possibly constrained) physical space of parameters is encoded in the prior object. The dynamical model Ψ accepts as inputs the parameters in (possibly constrained) physical space, so it is necessary to apply transform_unconstrained_to_constrained before evaluations. See the Prior distributions section for more details on parameter transformations.","category":"page"},{"location":"ensemble_kalman_inversion/#Solution","page":"Ensemble Kalman Inversion","title":"Solution","text":"","category":"section"},{"location":"ensemble_kalman_inversion/","page":"Ensemble Kalman Inversion","title":"Ensemble Kalman Inversion","text":"The EKI algorithm drives the initial ensemble, sampled from the prior, towards the support region of the posterior distribution. The algorithm also drives the ensemble members towards consensus. The optimal parameter θ_optim found by the algorithm is given by the mean of the last ensemble (i.e., the ensemble after the last iteration),","category":"page"},{"location":"ensemble_kalman_inversion/","page":"Ensemble Kalman Inversion","title":"Ensemble Kalman Inversion","text":"using Statistics\n\nθ_optim = mean(get_u_final(ekiobj), dims=2)","category":"page"},{"location":"API/ParameterDistribution/#ParameterDistribution","page":"ParameterDistribution","title":"ParameterDistribution","text":"","category":"section"},{"location":"API/ParameterDistribution/","page":"ParameterDistribution","title":"ParameterDistribution","text":"CurrentModule = EnsembleKalmanProcesses.ParameterDistributionStorage","category":"page"},{"location":"API/ParameterDistribution/","page":"ParameterDistribution","title":"ParameterDistribution","text":"Parameterized\nSamples\nConstraint\nno_constraint\nbounded_below\nbounded_above\nbounded\nlen\nn_samples\nParameterDistribution\nget_name\nget_dimensions\nget_n_samples\nget_all_constraints\nbatch\nget_distribution\nsample_distribution\nget_logpdf\nget_cov\nget_mean\ntransform_constrained_to_unconstrained\ntransform_unconstrained_to_constrained","category":"page"},{"location":"API/ParameterDistribution/#EnsembleKalmanProcesses.ParameterDistributionStorage.Parameterized","page":"ParameterDistribution","title":"EnsembleKalmanProcesses.ParameterDistributionStorage.Parameterized","text":"struct Parameterized <: ParameterDistributionType\n\nA distribution constructed from a parametrized formula (e.g Julia Distributions.jl)\n\n\n\n\n\n","category":"type"},{"location":"API/ParameterDistribution/#EnsembleKalmanProcesses.ParameterDistributionStorage.Samples","page":"ParameterDistribution","title":"EnsembleKalmanProcesses.ParameterDistributionStorage.Samples","text":"struct Samples{FT<:Real} <: ParameterDistributionType\n\nA distribution comprised of only samples, stored as columns of parameters\n\n\n\n\n\n","category":"type"},{"location":"API/ParameterDistribution/#EnsembleKalmanProcesses.ParameterDistributionStorage.Constraint","page":"ParameterDistribution","title":"EnsembleKalmanProcesses.ParameterDistributionStorage.Constraint","text":"struct Constraint <: ConstraintType\n\nContains two functions to map between constrained and unconstrained spaces.\n\n\n\n\n\n","category":"type"},{"location":"API/ParameterDistribution/#EnsembleKalmanProcesses.ParameterDistributionStorage.no_constraint","page":"ParameterDistribution","title":"EnsembleKalmanProcesses.ParameterDistributionStorage.no_constraint","text":"function no_constraint()\n\nConstructs a Constraint with no constraints, enforced by maps x -> x and x -> x.\n\n\n\n\n\n","category":"function"},{"location":"API/ParameterDistribution/#EnsembleKalmanProcesses.ParameterDistributionStorage.bounded_below","page":"ParameterDistribution","title":"EnsembleKalmanProcesses.ParameterDistributionStorage.bounded_below","text":"function bounded_below(lower_bound::FT) where {FT <: Real}\n\nConstructs a Constraint with provided lower bound, enforced by maps x -> log(x - lowerbound) and x -> exp(x) + lowerbound.\n\n\n\n\n\n","category":"function"},{"location":"API/ParameterDistribution/#EnsembleKalmanProcesses.ParameterDistributionStorage.bounded_above","page":"ParameterDistribution","title":"EnsembleKalmanProcesses.ParameterDistributionStorage.bounded_above","text":"function bounded_above(upper_bound::FT) where {FT <: Real}\n\nConstructs a Constraint with provided upper bound, enforced by maps x -> log(upperbound - x) and x -> upperbound - exp(x).\n\n\n\n\n\n","category":"function"},{"location":"API/ParameterDistribution/#EnsembleKalmanProcesses.ParameterDistributionStorage.bounded","page":"ParameterDistribution","title":"EnsembleKalmanProcesses.ParameterDistributionStorage.bounded","text":"function bounded(lower_bound::FT, upper_bound::FT) where {FT <: Real}\n\nConstructs a Constraint with provided upper and lower bounds, enforced by maps x -> log((x - lowerbound) / (upperbound - x)) and x -> (upperbound * exp(x) + lowerbound) / (exp(x) + 1)\n\n\n\n\n\n","category":"function"},{"location":"API/ParameterDistribution/#EnsembleKalmanProcesses.ParameterDistributionStorage.len","page":"ParameterDistribution","title":"EnsembleKalmanProcesses.ParameterDistributionStorage.len","text":"function len(c::Array{CType})\n\nThe number of constraints, each constraint has length 1.\n\n\n\n\n\n","category":"function"},{"location":"API/ParameterDistribution/#EnsembleKalmanProcesses.ParameterDistributionStorage.n_samples","page":"ParameterDistribution","title":"EnsembleKalmanProcesses.ParameterDistributionStorage.n_samples","text":"function n_samples(d::Samples)\n\nThe number of samples in the array\n\n\n\n\n\n","category":"function"},{"location":"API/ParameterDistribution/#EnsembleKalmanProcesses.ParameterDistributionStorage.ParameterDistribution","page":"ParameterDistribution","title":"EnsembleKalmanProcesses.ParameterDistributionStorage.ParameterDistribution","text":"struct ParameterDistribution\n\nStructure to hold a parameter distribution, always stored as an array of distributions\n\n\n\n\n\n","category":"type"},{"location":"API/ParameterDistribution/#EnsembleKalmanProcesses.ParameterDistributionStorage.get_name","page":"ParameterDistribution","title":"EnsembleKalmanProcesses.ParameterDistributionStorage.get_name","text":"function get_name(pd::ParameterDistribution)\n\nReturns a list of ParameterDistribution names\n\n\n\n\n\n","category":"function"},{"location":"API/ParameterDistribution/#EnsembleKalmanProcesses.ParameterDistributionStorage.get_dimensions","page":"ParameterDistribution","title":"EnsembleKalmanProcesses.ParameterDistributionStorage.get_dimensions","text":"function get_dimensions(pd::ParameterDistribution)\n\nThe number of dimensions of the parameter space\n\n\n\n\n\n","category":"function"},{"location":"API/ParameterDistribution/#EnsembleKalmanProcesses.ParameterDistributionStorage.get_n_samples","page":"ParameterDistribution","title":"EnsembleKalmanProcesses.ParameterDistributionStorage.get_n_samples","text":"function get_n_samples(pd::ParameterDistribution)\n\nThe number of samples in a Samples distribution\n\n\n\n\n\n","category":"function"},{"location":"API/ParameterDistribution/#EnsembleKalmanProcesses.ParameterDistributionStorage.get_all_constraints","page":"ParameterDistribution","title":"EnsembleKalmanProcesses.ParameterDistributionStorage.get_all_constraints","text":"function get_all_constraints(pd::ParameterDistribution)\n\nreturns the (flattened) array of constraints of the parameter distribution\n\n\n\n\n\n","category":"function"},{"location":"API/ParameterDistribution/#EnsembleKalmanProcesses.ParameterDistributionStorage.batch","page":"ParameterDistribution","title":"EnsembleKalmanProcesses.ParameterDistributionStorage.batch","text":"function batch(pd:ParameterDistribution)\n\nReturns a list of contiguous [collect(1:i), collect(i+1:j),... ] used to split parameter arrays by distribution dimensions\n\n\n\n\n\n","category":"function"},{"location":"API/ParameterDistribution/#EnsembleKalmanProcesses.ParameterDistributionStorage.get_distribution","page":"ParameterDistribution","title":"EnsembleKalmanProcesses.ParameterDistributionStorage.get_distribution","text":"function get_distribution(pd::ParameterDistribution)\n\nReturns a Dict of ParameterDistribution distributions, with the parameter names as dictionary keys. For parameters represented by Samples, the samples are returned as a 2D (parameterdimension x nsamples) array\n\n\n\n\n\n","category":"function"},{"location":"API/ParameterDistribution/#EnsembleKalmanProcesses.ParameterDistributionStorage.sample_distribution","page":"ParameterDistribution","title":"EnsembleKalmanProcesses.ParameterDistributionStorage.sample_distribution","text":"function sample_distribution(pd::ParameterDistribution)\n\nDraws samples from the parameter distributions returns an array, with parameters as columns\n\n\n\n\n\n","category":"function"},{"location":"API/ParameterDistribution/#EnsembleKalmanProcesses.ParameterDistributionStorage.get_logpdf","page":"ParameterDistribution","title":"EnsembleKalmanProcesses.ParameterDistributionStorage.get_logpdf","text":"function logpdf(pd::ParameterDistribution, xarray::Array{<:Real,1})\n\nObtains the independent logpdfs of the parameter distributions at xarray (non-Samples Distributions only), and returns their sum.\n\n\n\n\n\n","category":"function"},{"location":"API/ParameterDistribution/#EnsembleKalmanProcesses.ParameterDistributionStorage.get_cov","page":"ParameterDistribution","title":"EnsembleKalmanProcesses.ParameterDistributionStorage.get_cov","text":"function get_cov(pd::ParameterDistribution)\n\nreturns a blocked covariance of the distributions\n\n\n\n\n\n","category":"function"},{"location":"API/ParameterDistribution/#EnsembleKalmanProcesses.ParameterDistributionStorage.get_mean","page":"ParameterDistribution","title":"EnsembleKalmanProcesses.ParameterDistributionStorage.get_mean","text":"get_mean(pd::Parameterized)\n\nreturns a mean of parameterized distribution\n\n\n\n\n\nget_mean(pd::Samples)\n\nreturns a mean of the samples\n\n\n\n\n\nfunction get_mean(pd::ParameterDistribution)\n\nreturns a mean of the distirbutions\n\n\n\n\n\n","category":"function"},{"location":"API/ParameterDistribution/#EnsembleKalmanProcesses.ParameterDistributionStorage.transform_constrained_to_unconstrained","page":"ParameterDistribution","title":"EnsembleKalmanProcesses.ParameterDistributionStorage.transform_constrained_to_unconstrained","text":"function transform_constrained_to_unconstrained(pd::ParameterDistribution, x::Array{<:Real})\n\nApply the transformation to map (possibly constrained) parameters xarray into the unconstrained space\n\n\n\n\n\n","category":"function"},{"location":"API/ParameterDistribution/#EnsembleKalmanProcesses.ParameterDistributionStorage.transform_unconstrained_to_constrained","page":"ParameterDistribution","title":"EnsembleKalmanProcesses.ParameterDistributionStorage.transform_unconstrained_to_constrained","text":"function transform_unconstrained_to_constrained(pd::ParameterDistribution, xarray::Array{Real})\n\nApply the transformation to map parameters xarray from the unconstrained space into (possibly constrained) space\n\n\n\n\n\n","category":"function"},{"location":"API/EnsembleKalmanProcesses/#EnsembleKalmanProcesses","page":"EnsembleKalmanProcesses","title":"EnsembleKalmanProcesses","text":"","category":"section"},{"location":"API/EnsembleKalmanProcesses/","page":"EnsembleKalmanProcesses","title":"EnsembleKalmanProcesses","text":"CurrentModule = EnsembleKalmanProcesses","category":"page"},{"location":"API/EnsembleKalmanProcesses/","page":"EnsembleKalmanProcesses","title":"EnsembleKalmanProcesses","text":"","category":"page"},{"location":"#EnsembleKalmanProcesses","page":"Home","title":"EnsembleKalmanProcesses","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"EnsembleKalmanProcesses.jl (EKP) is a library of derivative-free Bayesian optimization techniques based on the Ensemble Kalman Filters, a well known family of approximate filters used for data assimilation. Currently, the following methods are implemented in the library:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Ensemble Kalman Inversion (EKI) - The traditional optimization technique based on the Ensemble Kalman Filter EnKF (Iglesias, Law, Stuart 2013),\nEnsemble Kalman Sampler (EKS) - also obtains a Gaussian Approximation of the posterior distribution, through a Monte Carlo integration (Garbuno-Inigo, Hoffmann, Li, Stuart 2020),\nUnscented Kalman Inversion (UKI) - also obtains a Gaussian Approximation of the posterior distribution, through a quadrature based integration approach (Huang Schneider Stuart 2020),\n[coming soon] Sparsity preserving Ensemble Kalman Inversion (SEKI) - Additionally adds approximate L^0 and L^1 penalization to the EKI (Schneider, Stuart, Wu 2020).","category":"page"},{"location":"","page":"Home","title":"Home","text":"Module Purpose\nEnsembleKalmanProcesses.jl Collection of all tools\nEnsembleKalmanProcess.jl Implementations of EKI, EKS and UKI\nObservations.jl Structure to hold observational data\nParameterDistributions.jl Structures to hold prior and posterior distributions\nDataStorage.jl Structure to hold model parameters and outputs","category":"page"},{"location":"API/DataStorage/#DataStorage","page":"DataStorage","title":"DataStorage","text":"","category":"section"},{"location":"API/DataStorage/","page":"DataStorage","title":"DataStorage","text":"CurrentModule = EnsembleKalmanProcesses.DataStorage","category":"page"},{"location":"API/DataStorage/","page":"DataStorage","title":"DataStorage","text":"DataContainer\nPairedDataContainer\nsize","category":"page"},{"location":"API/DataStorage/#EnsembleKalmanProcesses.DataStorage.DataContainer","page":"DataStorage","title":"EnsembleKalmanProcesses.DataStorage.DataContainer","text":"struct DataContainer{FT <: Real}\n\nstruct to store data samples as columns in an array\n\n\n\n\n\n","category":"type"},{"location":"API/DataStorage/#EnsembleKalmanProcesses.DataStorage.PairedDataContainer","page":"DataStorage","title":"EnsembleKalmanProcesses.DataStorage.PairedDataContainer","text":"PairedDataContainer{FT <: Real}\n\nstores input - output pairs as data containers, there must be an equal number of inputs and outputs\n\n\n\n\n\n","category":"type"},{"location":"API/DataStorage/#Base.size","page":"DataStorage","title":"Base.size","text":"size(dc::DataContainer,idx::IT) where {IT <: Integer}\n\nreturns the size of the stored data (if idx provided, it returns the size along dimension idx) \n\n\n\n\n\nsize(pdc::PairedDataContainer,idx::IT) where {IT <: Integer}\n\nreturns the sizes of the inputs and ouputs along dimension idx (if provided)\n\n\n\n\n\n","category":"function"}]
}
